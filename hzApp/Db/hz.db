# hz.db - Database EPICS Modbus HAZEMEYER Iocaste Power Supply
# This file contains the database records for the HAZEMEYER Iocaste Power Supply
# It includes the project code, customer number, and various control and status registers.

# Direct Modbus addresses without substitutions


record(ai, "$(P)$(R)current") {
    field(DESC, "Current Raw Value")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),12,$(TIMEOUT))FLOAT32_LE") 
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R)voltage") {
    field(DESC, "Voltage Raw Value")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),14,$(TIMEOUT))FLOAT32_LE") 
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R)ramp") {
    field(DESC, "Ramp current")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),10,$(TIMEOUT))FLOAT32_LE") 
    field(SCAN, "1 second")
}

record(longin, "$(P)$(R)status_raw") {
    field(DESC, "Raw Status Value")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),16,1)")
    field(SCAN, "1 second")
}




# record(mbbi, "$(P)$(R)status") {
#     field(DESC, "Current Raw Value")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0xFFFF,1)")
#     field(SCAN, "1 second")
#     field(ZRVL, 0)    field(ZRST, "POWER OFF")
#     field(ONVL, 1)    field(ONST, "POWER ON")
#     field(TWVL, 2)    field(TWST, "GLOBAL FAULT")
#     field(THVL, 3)    field(THST, "READY")
#     field(FRVL, 4)    field(FRST, "REMOTE")
#     field(FVVL, 5)    field(FVST, "LOCAL")
#     field(SXVL, 6)    field(SXST, "REGULATION OK")
#     field(SVVL, 7)    field(SVST, "BIT 7")
#     field(EIVL, 8)    field(EIST, "BIT 8")
#     field(NIVL, 9)    field(NIST, "BIT 9")
#     field(TEVL,10)    field(TEST, "BIT 10")
#     field(ELVL,11)    field(ELST, "BIT 11")
#     field(TVVL, 12)   field(TVST, "BIT 12")
#     field(TTVL, 13)   field(TTST, "BIT 13")
#     field(FTVL, 14)   field(FTST, "BIT 14")
#     field(FFVL, 15)   field(FFST, "BIT 15")
# }


record(mbbi, "$(P)$(R)powerStatus") {
    field(DESC, "Power State")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT), 0, 0x3, 0)")
    field(ZRVL, 0) field(ZRST, "OFF")
    field(ONVL, 1) field(ONST, "ON")
    field(SCAN, "1 second")
}

# record(bi, "$(P)$(R)power_on") {
#     field(DESC, "Power On Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0001,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "OFF")
#     field(ONAM, "ON")
# }

# record(bi, "$(P)$(R)power_off") {
#     field(DESC, "Power Off Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0002,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "NORMAL")
#     field(ONAM, "POWER OFF")
# }

record(bi, "$(P)$(R)global_fault") {
    field(DESC, "Global Fault Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0004,1)")
    field(SCAN, "1 second")
    field(ZNAM, "OK")
    field(ONAM, "FAULT")
}

record(bi, "$(P)$(R)ready") {
    field(DESC, "Ready Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0008,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NOT READY")
    field(ONAM, "READY")
}


# Anche remote e local potrebbero essere degli mbbi

record(bi, "$(P)$(R)remote") {
    field(DESC, "Remote Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0010,1)")
    field(SCAN, "1 second")
    field(ZNAM, "LOCAL")
    field(ONAM, "REMOTE")
}

record(bi, "$(P)$(R)local") {
    field(DESC, "Local Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0020,1)")
    field(SCAN, "1 second")
    field(ZNAM, "REMOTE")
    field(ONAM, "LOCAL")
}

record(bi, "$(P)$(R)regulation_ok") {
    field(DESC, "Regulation OK Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0040,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NOT OK")
    field(ONAM, "OK")
}
# hz.db - Hazemeyer Power Supply Control Database
# Provides EPICS interface for Hazemeyer power supplies via Modbus

# =========================
# Channel Set current (0x0006)
# =========================
record(ao, "$(P):$(R):CURRENT_SP") {
    field(DESC, "Channel Set Current")
    field(EGU, "A")
    field(PREC, "2")
    field(DRVL, "0")
    field(DRVH, "$(IMAX)")
    field(FLNK, "$(P):$(R):CALC_CURRENT_RAW")
}

record(calcout, "$(P):$(R):CALC_CURRENT_RAW") {
    field(DESC, "Convert current to raw value")
    field(INPA, "$(P):$(R):CURRENT_SP")
    field(CALC, "(A * 32767)/$(IMAX)")
    field(OUT, "$(P):$(R):RAW_CURRENT_SP")
    field(FLNK, "$(P):$(R):RAW_CURRENT_SP")
}

record(ao, "$(P):$(R):RAW_CURRENT_SP") {
    field(DESC, "Raw current setpoint")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(WPORT),2,$(TIMEOUT))MODBUS_DATA")
    field(PREC, "0")
    field(FLNK, "$(P):$(R):AUTO_START_RAMP")
}

record(calcout, "$(P):$(R):AUTO_START_RAMP") {
    field(DESC, "Auto Start Ramp with delay")
    field(CALC, "1")
    field(OUT, "$(P):$(R):DELAY_RAMP.PROC")
}

record(seq, "$(P):$(R):DELAY_RAMP") {
    field(DESC, "Delay before setting ramp bit")
    field(DOL1, "16")
    field(LNK1, "$(P):$(R):RAW_STATE_SP PP")
    field(DLY1, "0.5")
    field(SELM, "All")
}

# =========================
# Channel Set Slew Rate (0x0007)
# =========================
record(ao, "$(P):$(R):SLEWRATE_SP") {
    field(DESC, "Channel Set Slew Rate")
    field(EGU, "A/s")
    field(PREC, "2")
    field(DRVL, "0")
    field(DRVH, "$(IMAX)")
    field(FLNK, "$(P):$(R):CALC_SLEWRATE_RAW")
}

record(calcout, "$(P):$(R):CALC_SLEWRATE_RAW") {
    field(DESC, "Convert slew rate to raw value")
    field(INPA, "$(P):$(R):SLEWRATE_SP")
    field(CALC, "(A * 32767)/$(IMAX)")
    field(OUT, "$(P):$(R):RAW_SLEWRATE_SP")
    field(FLNK, "$(P):$(R):RAW_SLEWRATE_SP")
}

record(ao, "$(P):$(R):RAW_SLEWRATE_SP") {
    field(DESC, "Raw slew rate setpoint")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(WPORT),3,$(TIMEOUT))MODBUS_DATA")
    field(PREC, "0")
}

# =========================
# Status Registers (0x000A, 0x000B)
# =========================
record(mbbiDirect, "$(P):$(R):RAW_STATE_RB") {
    field(DESC, "Raw State Register 1")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT) 6 0xFFFF $(TIMEOUT))MODBUS_DATA")
    field(SCAN, "1 second")
    field(FLNK, "$(P):$(R):RAW_STATE2_RB")
}

record(mbbiDirect, "$(P):$(R):RAW_STATE2_RB") {
    field(DESC, "Raw State Register 2")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT) 11 0xFFFF $(TIMEOUT))MODBUS_DATA")
    field(NOBT, "16")
    field(FLNK, "$(P):$(R):state_calc")
}

# =========================
# Maximum Values
# =========================
record(ai, "$(P):$(R):IMAX") {
    field(DESC, "Maximum current")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(VAL, "$(IMAX)")
    field(EGU, "A")
}

record(ai, "$(P):$(R):VMAX") {
    field(DESC, "Maximum voltage")
    field(SCAN, "Passive")
    field(PINI, "YES")
    field(VAL, "$(VMAX)")
    field(EGU, "V")
}

# =========================
# Output current readback (0x000B)
# =========================
record(ai, "$(P):$(R):RAW_CURRENT_RB") {
    field(DESC, "Raw output current readback")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),7,$(TIMEOUT))MODBUS_DATA")
    field(SCAN, "1 second")
    field(FLNK, "$(P):$(R):CURRENT_RB")
}

record(calc, "$(P):$(R):CURRENT_RB") {
    field(DESC, "Output current readback")
    field(INPA, "$(P):$(R):RAW_CURRENT_RB")
    field(INPB, "$(P):$(R):IMAX")
    field(CALC, "(A / 32767) * B")
    field(PREC, "3")
    field(EGU, "A")
}

# =========================
# Output voltage readback (0x000C)
# =========================
record(ai, "$(P):$(R):RAW_VOLTAGE_RB") {
    field(DESC, "Raw output voltage readback")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),8,$(TIMEOUT))MODBUS_DATA")
    field(SCAN, "1 second")
    field(FLNK, "$(P):$(R):VOLTAGE_RB")
}

record(calc, "$(P):$(R):VOLTAGE_RB") {
    field(DESC, "Output voltage readback")
    field(INPA, "$(P):$(R):RAW_VOLTAGE_RB")
    field(INPB, "$(P):$(R):VMAX")
    field(CALC, "(A / 32767) * B")
    field(PREC, "3")
    field(EGU, "V")
}

# =========================
# Output earth current readback (0x000D)
# =========================
record(ai, "$(P):$(R):EARTH_CURRENT_RB") {
    field(DESC, "Earth current readback")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),9,$(TIMEOUT))MODBUS_DATA")
    field(LINR, "LINEAR")
    field(ESLO, "0.001")
    field(EGU, "A")
    field(PREC, "3")
    field(LOPR, "0")
    field(HOPR, "32.767")
    field(SCAN, "1 second")
}

# =========================
# Set current readback (0x000E)
# =========================
record(ai, "$(P):$(R):SET_CURRENT_RB") {
    field(DESC, "Set current readback")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),10,$(TIMEOUT))MODBUS_DATA")
    field(LINR, "LINEAR")
    field(ESLO, "0.001")
    field(EGU, "A")
    field(PREC, "3")
    field(LOPR, "0")
    field(HOPR, "32.767")
    field(SCAN, "1 second")
}

# =========================
# Command Register (0x0000)
# =========================
record(ao, "$(P):$(R):RAW_STATE_SP") {
    field(DESC, "Raw command register")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(WPORT),0,$(TIMEOUT))MODBUS_DATA")
}

# =========================
# High-Level State Control
# =========================
record(mbbo, "$(P):$(R):STATE_SP") {
    field(DESC, "State setpoint")
    field(ZRVL, "0")
    field(ZRST, "OFF")
    field(ONVL, "1")
    field(ONST, "ON")
    field(TWVL, "2")
    field(TWST, "STANDBY")
    field(THVL, "3")
    field(THST, "RESET")
    field(FRVL, "4")
    field(FRST, "INTERLOCK")
    field(FVVL, "5")
    field(FVST, "ERROR")
    field(FLNK, "$(P):$(R):state_to_enable")
}

record(seq, "$(P):$(R):state_to_enable") {
    field(DESC, "Convert state to command")
    field(DOL1, "2")   # ON -> Power On (value 2)
    field(LNK1, "$(P):$(R):RAW_STATE_SP PP")
    field(DOL2, "1")   # STANDBY -> Standby (value 1) 
    field(LNK2, "$(P):$(R):RAW_STATE_SP PP")
    field(DOL3, "8")   # RESET -> Reset (value 8)
    field(LNK3, "$(P):$(R):RAW_STATE_SP PP")
    field(SELM, "Specified")
    field(SELL, "$(P):$(R):STATE_SP")
    field(SCAN, "Passive")
}

record(mbbi, "$(P):$(R):STATE_RB") {
    field(DESC, "State readback")
    field(SCAN, "Passive")
    field(ZRVL, "0")
    field(ZRST, "OFF")
    field(ONVL, "1")
    field(ONST, "ON")
    field(TWVL, "2")
    field(TWST, "STANDBY")
    field(THVL, "3")
    field(THST, "RESET")
    field(FRVL, "4")
    field(FRST, "INTERLOCK")
    field(FRSV, "MAJOR")
    field(FVVL, "5")
    field(FVST, "ERROR")
    field(FVSV, "MAJOR")
}

# =========================
# Status Interpretation
# =========================
record(bi, "$(P):$(R):ALL_FAULT") {
    field(DESC, "Fault status")
    field(INP, "$(P):$(R):RAW_STATE_RB.B3 MS CP")
    field(ZNAM, "OK")
    field(ONAM, "FAULT")
    field(ZSV, "NO_ALARM")
    field(OSV, "MAJOR")
}

record(bi, "$(P):$(R):OPERATIONAL") {
    field(DESC, "Operational status")
    field(INP, "$(P):$(R):RAW_STATE_RB.B0 MS CP")
    field(ZNAM, "OFF")
    field(ONAM, "ON")
}

record(calcout, "$(P):$(R):state_calc") {
    field(DESC, "Calculate state from status bits")
    field(INPA, "$(P):$(R):OPERATIONAL")
    field(INPB, "$(P):$(R):ALL_FAULT")
    field(CALC, "B=1 ? 4 : (A=1 ? 1 : 2)")
    field(OUT, "$(P):$(R):STATE_RB PP")
    field(OOPT, "Every Time")
}

# 2025-09-25 SWVER=1.0.2
# hz_iocst.db - Database EPICS Modbus HAZEMEYER Iocaste Power Supply
# This file contains the database records for the HAZEMEYER Iocaste Power Supply
# It includes the project code, customer number, and various control and status registers.

# Direct Modbus addresses without substitutions

########################################################################################
### Software Version
########################################################################################

record(stringout, "$(P)$(R):SWVER") {
    field(DESC, "Software IOC Version")
    field(VAL, "$(SWVER=1.0.2)")
    field(PINI, "YES")
}


########################################################################################
### READOUT - Compliant with HAZEMEYER Iocaste Power Supply - Holding Registers Table
########################################################################################

record(ai, "$(P)$(R):current_rb") {
    field(DESC, "Current Value")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),12,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A")
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R):voltage_rb") {
    field(DESC, "Voltage Value")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),14,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "V")
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R):ramp_rb") {
    field(DESC, "Ramp current")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),10,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A/s")
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R):current_set_point_rb") {
    field(DESC, "Setted Current register")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),8,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A")
    field(SCAN, "1 second")
}

record(longin, "$(P)$(R):status_raw") {
    field(DESC, "Raw Status Value")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),16,1)")
    field(SCAN, "1 second")
}

record(mbbiDirect, "$(P)$(R):statusDirect") {
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0xFFFF,1)")
    field(SCAN, "I/O Intr")

}


# This record (mbbi type) avoids using power_on (bi type) and power_off (bi type)

record(mbbi, "$(P)$(R):powerStatus") {
    field(DESC, "Power State")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT), 16, 0x3, 0)")  # It reads bits 0â€“1 of register 16.
    field(ONVL, 1) field(ONST, "POWER ON")              # 01 = ON
    field(TWVL, 2) field(TWST, "POWER OFF")             # 10 = OFF
    field(UNSV, "MAJOR")                          # If the value is not 1 or 2, it raises an alarm.
    field(UDF, "1")                               # Indicates an undefined value at startup.
    field(SCAN, "1 second")                       # Polling every second
}

# record(bi, "$(P)$(R):power_on") {
#     field(DESC, "Power On Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0001,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "OFF")
#     field(ONAM, "ON")
# }

# record(bi, "$(P)$(R):power_off") {
#     field(DESC, "Power Off Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0002,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "NORMAL")
#     field(ONAM, "POWER OFF")
# }

record(bi, "$(P)$(R):global_fault") {
    field(DESC, "Global Fault Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0004,1)")
    field(SCAN, "1 second")
    field(ZNAM, "OK")
    field(ONAM, "FAULT")
}

record(bi, "$(P)$(R):ready") {
    field(DESC, "Ready Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0008,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NOT READY")
    field(ONAM, "READY")
}


# This record (mbbi type) avoids using power_on (bi type) and power_off (bi type)

record(mbbi, "$(P)$(R):accessMode") {
    field(DESC, "Access Mode: Local/Remote")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT), 16, 0x0030, 4)")  # Read 4 and 5 bits, shifted by 4 bits
    field(SCAN, "1 second")

    field(ZRVL, 0)     field(ZRST, "UNKNOWN")   # 00
    field(ONVL, 1)     field(ONST, "REMOTE")    # 01 (bit 4 = 1)
    field(TWVL, 2)     field(TWST, "LOCAL")     # 10 (bit 5 = 1)
    field(THVL, 3)     field(THST, "INVALID")   # 11
    field(UNSV, "MAJOR")
}


# record(bi, "$(P)$(R):remote") {
#     field(DESC, "Remote Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0010,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "LOCAL")
#     field(ONAM, "REMOTE")
# }

# record(bi, "$(P)$(R):local") {
#     field(DESC, "Local Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0020,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "REMOTE")
#     field(ONAM, "LOCAL")
# }

record(bi, "$(P)$(R):regulation_ok") {
    field(DESC, "Regulation OK Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0040,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NOT OK")
    field(ONAM, "OK")
}

record(mbbiDirect, "$(P)$(R):faults1") {
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),17,0xFFFF,1)")
    field(SCAN, "I/O Intr")

}

record(mbbiDirect, "$(P)$(R):faults2") {
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),18,0xFFFF,1)")
    field(SCAN, "I/O Intr")

}

########################################################################################
### SETTINGS - Compliant with HAZEMEYER Iocaste Power Supply - Holding Registers Table
########################################################################################

record(ao, "$(P)$(R):current_set") {
    field(DESC, "Set Current")
    field(DTYP, "asynFloat64")  
    field(OUT, "@asyn($(WPORT),2,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A")
    field(SCAN, "Passive")
}

record(ao, "$(P)$(R):ramp_set") {
    field(DESC, "Set Ramp")
    field(DTYP, "asynFloat64")  
    field(OUT, "@asyn($(WPORT),6,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A/s")
    field(SCAN, "Passive")
}

record(bo, "$(P)$(R):power_on") {
    field(DESC, "Power On Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0001,1)")
    field(SCAN, "Passive")
    field(ZNAM, "Normal")
    field(ONAM, "Power_ON")
}

record(bo, "$(P)$(R):power_off") {
    field(DESC, "Power Off Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0002,1)")
    field(SCAN, "Passive")
    field(ZNAM, "Normal")
    field(ONAM, "Power_OFF")
}


record(bo, "$(P)$(R):reset") {
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0004,1)")
    field(SCAN, "Passive")
    field(ZNAM, "Normal")
    field(ONAM, "Reset")
}


record(bo, "$(P)$(R):ramp_start") {
    field(DESC, "Ramp Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0008,1)")
}

########################################################################################
### EPIK8s - PVs for UNIMAG Class
########################################################################################

record(ai, "$(P)$(R):CURRENT_RB") {
    field(DESC, "Current Value")
    field(INP, "$(P)$(R):current_rb CP")
    field(EGU, "A")
}

########################################################
### CURRENT_SP : 500 ms before ramp_start - for UNIMAG
########################################################

record(ao, "$(P)$(R):CURRENT_SP") {
    field(DESC, "Set Current with Ramp")
    field(EGU, "A")
    field(FLNK, "$(P)$(R):current_set_calc")
}

record(calcout, "$(P)$(R):current_set_calc") {
    field(INPA, "$(P)$(R):CURRENT_SP")
    field(CALC, "A")
    field(OUT, "$(P)$(R):current_set PP")
    field(FLNK, "$(P)$(R):ramp_delay")
}

record(seq, "$(P)$(R):ramp_delay") {
    field(DESC, "Delay before ramp")
    field(DLY1, "0.5") 
    field(DOL1, "1")
    field(LNK1, "$(P)$(R):ramp_start PP")
}


###################################################
### STATE_RB for UNIMAG
###################################################


record(calc, "$(P):$(R):STATE_RB_CALC") {
    field(DESC, "State readback")
    field(INPA, "$(P)$(R):powerStatus CP")      # Power Status (1=ON, 2=OFF)
    field(INPB, "$(P)$(R):ready CP")            # Ready (0=NOT READY, 1=READY)
    field(INPC, "$(P)$(R):global_fault CP")     # Global Fault (0=OK, 1=FAULT)
    field(CALC, "C?4:(A=2?0:(A=1&&B?1:2))")     # Logic
    field(SCAN, "Passive")                      # Updated from CP
}


record(mbbi, "$(P):$(R):STATE_RB") {
    field(DESC, "State readback string")
    field(INP, "$(P):$(R):STATE_RB_CALC CP MS")
    field(SCAN, "Passive")
    field(ZRVL, "0")
    field(ZRST, "OFF")
    field(ONVL, "1")
    field(ONST, "ON")
    field(TWVL, "2")
    field(TWST, "STANDBY")
    field(THVL, "3")
    field(THST, "RESET")
    field(FRVL, "4")
    field(FRST, "FAULT")
    field(FRSV, "MAJOR")
    field(FVVL, "5")
    field(FVST, "ERROR")
    field(FVSV, "MAJOR")
}

######################################################
### STATE_SP | ON, STABY, RST 
######################################################

record(mbbo, "$(P):$(R):STATE_SP") {
    field(DESC, "State setpoint")
    field(ZRVL, "0")
    field(ZRST, "OFF")
    field(ONVL, "1")
    field(ONST, "ON")
    field(TWVL, "2")
    field(TWST, "STANDBY")
    field(THVL, "3")
    field(THST, "RESET")
    field(FRVL, "4")
    field(FRST, "FAULT")
    field(FVVL, "5")
    field(FVST, "ERROR")
    field(FLNK, "$(P):$(R):state_dispatcher")
}

record(seq, "$(P):$(R):state_dispatcher") {
    field(SELM, "Specified")
    field(SELL, "$(P):$(R):STATE_SP")
    field(DOL1, "1")
    field(LNK1, "$(P)$(R):power_on.VAL PP")  # ON (value 1)
    field(DOL4, "1")
    field(LNK4, "$(P)$(R):reset.VAL PP")     # FAULT (value 4)
}
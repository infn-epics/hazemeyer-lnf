# hz_iocst.db - Database EPICS Modbus HAZEMEYER Iocaste Power Supply
# This file contains the database records for the HAZEMEYER Iocaste Power Supply
# It includes the project code, customer number, and various control and status registers.

# Direct Modbus addresses without substitutions

########################################################################################
### READOUT - Compliant with HAZEMEYER Iocaste Power Supply - Holding Registers Table
########################################################################################

record(ai, "$(P)$(R)current_rb") {
    field(DESC, "Current Value")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),12,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A")
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R)voltage_rb") {
    field(DESC, "Voltage Value")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),14,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "V")
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R)ramp_rb") {
    field(DESC, "Ramp current")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),10,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A/s")
    field(SCAN, "1 second")
}

record(ai, "$(P)$(R)current_set_point_rb") {
    field(DESC, "Setted Current register")
    field(DTYP, "asynFloat64")  
    field(INP, "@asyn($(PORT),8,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A")
    field(SCAN, "1 second")
}

record(longin, "$(P)$(R)status_raw") {
    field(DESC, "Raw Status Value")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),16,1)")
    field(SCAN, "1 second")
}

record(mbbiDirect, "$(P)$(R)statusDirect") {
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0xFFFF,1)")
    field(SCAN, "I/O Intr")

}

# Questo record evita di usare power_on (tipo bi) e power_off (tipo bi)

record(mbbi, "$(P)$(R)powerStatus") {
    field(DESC, "Power State")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT), 16, 0x3, 0)")  # legge i bit 0–1 del registro 16
    field(ONVL, 1) field(ONST, "POWER ON")              # 01 = ON
    field(TWVL, 2) field(TWST, "POWER OFF")             # 10 = OFF
    field(UNSV, "MAJOR")                          # Se il valore non è 1 o 2, segnala un allarme
    field(UDF, "1")                               # Segnala valore indefinito all'avvio
    field(SCAN, "1 second")                       # Polling ogni secondo
}

# record(bi, "$(P)$(R)power_on") {
#     field(DESC, "Power On Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0001,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "OFF")
#     field(ONAM, "ON")
# }

# record(bi, "$(P)$(R)power_off") {
#     field(DESC, "Power Off Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0002,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "NORMAL")
#     field(ONAM, "POWER OFF")
# }

record(bi, "$(P)$(R)global_fault") {
    field(DESC, "Global Fault Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0004,1)")
    field(SCAN, "1 second")
    field(ZNAM, "OK")
    field(ONAM, "FAULT")
}

record(bi, "$(P)$(R)ready") {
    field(DESC, "Ready Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0008,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NOT READY")
    field(ONAM, "READY")
}


# Questo record evita di usare local (tipo bi) e remote (tipo bi)

record(mbbi, "$(P)$(R)accessMode") {
    field(DESC, "Access Mode: Local/Remote")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT), 16, 0x0030, 4)")  # Leggi bits 4-5 e shiftali di 4 bit
    field(SCAN, "1 second")

    field(ZRVL, 0)     field(ZRST, "UNKNOWN")   # 00
    field(ONVL, 1)     field(ONST, "REMOTE")    # 01 (bit 4 = 1)
    field(TWVL, 2)     field(TWST, "LOCAL")     # 10 (bit 5 = 1)
    field(THVL, 3)     field(THST, "INVALID")   # 11
    field(UNSV, "MAJOR")
}


# record(bi, "$(P)$(R)remote") {
#     field(DESC, "Remote Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0010,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "LOCAL")
#     field(ONAM, "REMOTE")
# }

# record(bi, "$(P)$(R)local") {
#     field(DESC, "Local Status")
#     field(DTYP, "asynUInt32Digital")
#     field(INP, "@asynMask($(PORT),16,0x0020,1)")
#     field(SCAN, "1 second")
#     field(ZNAM, "REMOTE")
#     field(ONAM, "LOCAL")
# }

record(bi, "$(P)$(R)regulation_ok") {
    field(DESC, "Regulation OK Status")
    field(DTYP, "asynUInt32Digital")
    field(INP, "@asynMask($(PORT),16,0x0040,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NOT OK")
    field(ONAM, "OK")
}


########################################################################################
### SETTINGS - Compliant with HAZEMEYER Iocaste Power Supply - Holding Registers Table
########################################################################################

record(ao, "$(P)$(R)current_set") {
    field(DESC, "Set Current")
    field(DTYP, "asynFloat64")  
    field(OUT, "@asyn($(WPORT),2,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A")
    field(SCAN, "1 second")
}

record(ao, "$(P)$(R)ramp_set") {
    field(DESC, "Set Ramp")
    field(DTYP, "asynFloat64")  
    field(OUT, "@asyn($(WPORT),6,$(TIMEOUT))FLOAT32_LE") 
    field(EGU, "A/s")
    field(SCAN, "1 second")
}

record(bo, "$(P)$(R)power_on") {
    field(DESC, "Power On Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0001,1)")
    field(SCAN, "1 second")
    field(ZNAM, "OFF")
    field(ONAM, "ON")
}

record(bo, "$(P)$(R)power_off") {
    field(DESC, "Power Off Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0002,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NORMAL")
    field(ONAM, "POWER OFF")
}

record(bo, "$(P)$(R)reset") {
    field(DESC, "Reset Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0004,1)")
    field(SCAN, "1 second")
    field(ZNAM, "NORMAL")
    field(ONAM, "RESET")
}

record(bo, "$(P)$(R)ramp_start") {
    field(DESC, "Ramp Command")
    field(DTYP, "asynUInt32Digital")
    field(OUT, "@asynMask($(WPORT),0,0x0008,1)")
}
